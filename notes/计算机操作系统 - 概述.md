<!-- GFM-TOC -->
* [基本特征](#基本特征)
    * [1. 并发](#1-并发)
    * [2. 共享](#2-共享)
    * [3. 虚拟](#3-虚拟)
    * [4. 异步](#4-异步)
* [基本功能](#基本功能)
    * [1. 进程管理](#1-进程管理)
    * [2. 内存管理](#2-内存管理)
    * [3. 文件管理](#3-文件管理)
    * [4. 设备管理](#4-设备管理)
* [大内核和微内核](#大内核和微内核)
    * [1. 大内核](#1-大内核)
    * [2. 微内核](#2-微内核)
* [中断分类](#中断分类)
    * [1. 外中断](#1-外中断)
    * [2. 异常](#2-异常)
    * [3. 陷入](#3-陷入)
* [用户态和内核态](#用户态和内核态)

<!-- GFM-TOC -->


# 基本特征

## 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 基本功能

## 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

## 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

## 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

## 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。


# 大内核和微内核

## 1. 大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

## 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

# 中断分类

## 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

## 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

## 3. 陷入

在用户程序中使用系统调用。

# 用户态和内核态

## 为什么会有用户态和内核态

最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。

当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。

## 状态切换

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于`内核运行态`（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。

每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于`用户运行态`（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

## 开销

当程序执行系统调用时，首先使用类似int 80H的软中断指令，保存现场，取得系统调用号，在内核态执行，然后恢复现场。每个进程都会有两个栈，一个内核态栈和一个用户态栈，系统调用时需要进行栈的切换。而且内核代码对用户不信任，需要进行额外的检查。系统调用的返回过程有很多额外工作，比如检查是否需要调度等。 


用户态切换到内核态的3种方式:
- **系统调用**: 比如fork()、open()等函数。
- **异常**: 比如缺页异常。
- **外围设备的中断**: 比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。